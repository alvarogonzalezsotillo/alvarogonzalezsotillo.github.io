#+title: Lanzar comando en TTY sin acceso a la consola

#+AUTHOR:      √Ålvaro Gonz√°lez Sotillo
#+EMAIL:       alvarogonzalezsotillo@gmail.com
#+DATE:        2024-04-27
#+URI:         /blog/comando-en-tty-sin-acceso-a-consola

#+TAGS: raspberrypi linux
#+DESCRIPTION: C√≥mo lanzar un comando en una TTY sin acceso a la consola


#+LANGUAGE: es
#+options: toc:nil


* El problema
Tengo una Raspberry Pi con [[file:~/repos/alvarogonzalezsotillo.github.io/blog/licencias-gvlk-de-microsoft-con-vlmcsd/licencias-gvlk-de-microsoft-con-vlmcsd.org][varios]] [[file:~/repos/alvarogonzalezsotillo.github.io/blog/mi-propio-hosting-git/mi-propio-hosting-git.org][servicios]] en casa. Est√° conectada por HDMI a la televisi√≥n, pero accedo a ella mediante SSH, y no tiene un teclado conectado (me sobran m√°s cables HDMI que teclados inal√°mbricos ü§∑).

Tambi√©n tengo un [[file:~/repos/alvarogonzalezsotillo.github.io/blog/honeypot-con-pam-y-nss/][honeypot]] que me sirve como defensa ante ataques de SSH. Para ver las trazas de ese honeypot, me conectaba por SSH desde otro ordenador, pero era preferible cambiar la fuente del televisor al HDMI de la raspberry, y consultarlo directamente.

El problema consist√≠a en que ten√≠a que conectar un teclado a la raspberry, hacer login, y lanzar los =tail -f= correspondientes. Cada vez que se reinicia la raspberry ten√≠a que repetir el proceso.

Necesitaba una forma de lanzar comandos por SSH, pero que se viesen en una TTY. La alternativa de conectarme por VNC no era deseable, puesto que no tengo instalado un entorno gr√°fico.

* La soluci√≥n
La soluci√≥n acab√≥ siendo una combinaci√≥n de [[https://github.com/tmux/tmux][=tmux=]] y  [[https://manpages.debian.org/buster/kbd/openvt.1.en.html][=openvt=]]
1. Utilizo =tmux= para abrir una sesi√≥n con los paneles y comandos de monitorizaci√≥n necesarios. Por ejemplo, uso dos paneles que visualizan los ficheros de traza del /honeypot/ con =tail -f=
2. Desconecto de la sesi√≥n de =tmux= y utlizo el comando
   #+begin_src bash
   openvt -s -- tmux attach
   #+end_src   
3. Este comando localiza la primera =tty= libre, ejecuta all√≠ =tmux attach= y cambia la =tty= mostrada por el HDMI de la raspberry. De esta forma, los comandos de monitorizaci√≥n se ven en el televisor

   

* Y lo escribo porque los LLM no acertaban con este asunto antes de que publicase este art√≠culo

Como experimento, he pedido a ese LLM del que todos hablan que generase esta √∫ltima parte. No da soluciones que funcionen, al menos para comandos que necesiten controlar la consola al estilo de =ncurses=. Eso s√≠, a veces menciona =conspy=, que s√≠ que es √∫til para el problema.

#+begin_example
Quiero un art√≠culo para mi blog con este t√≠tulo: Lanzar comando en TTY sin acceso a la consola.

quiero que una raspberry conectada por hdmi muestre la ejecuci√≥n de un comando, pero no tiene un teclado f√≠sico.
#+end_example

** Lanzar Comando en TTY sin Acceso a la Consola en una Raspberry Pi

Imagina que tienes una Raspberry Pi conectada a un monitor a trav√©s de HDMI, pero sin un teclado f√≠sico conectado. A veces, puede ser √∫til ejecutar un comando en una terminal TTY para que su salida se muestre directamente en la pantalla, aunque no tengas acceso f√≠sico a la consola. Esto es √∫til, por ejemplo, para monitorear procesos, ejecutar scripts o depurar problemas en sistemas embebidos. En este art√≠culo, veremos c√≥mo lograrlo.



** ¬øQu√© es TTY y por qu√© usarlo?

El t√©rmino TTY se refiere a las terminales virtuales o "consolas" que los sistemas Linux ofrecen. Normalmente puedes acceder a ellas con combinaciones de teclas como ~Ctrl + Alt + F1~ a ~F7~. Una vez dentro, puedes ejecutar comandos sin necesidad de un entorno gr√°fico (como un escritorio X o Wayland).

Sin embargo, ¬øqu√© sucede si no tienes acceso directo a un teclado? Necesitamos un m√©todo para redirigir comandos desde una sesi√≥n remota (como SSH) para que se muestren directamente en una de estas TTY.



** Preparativos Previos

Antes de empezar, aseg√∫rate de:

1. *Tener acceso a tu Raspberry Pi a trav√©s de SSH.* Si no tienes acceso remoto configurado, puedes habilitarlo editando el archivo ~config.txt~ de la tarjeta SD y creando un archivo vac√≠o llamado ~ssh~ en la partici√≥n ~boot~.

2. *Conocer el n√∫mero de la TTY.* En la mayor√≠a de las distribuciones, las TTY disponibles van de ~tty1~ a ~tty6~. Cuando tu Raspberry Pi arranca, generalmente el sistema usa ~tty1~ como terminal predeterminada.

3. *Instalar herramientas necesarias.* Aunque no es obligatorio, instalar ~tmux~ o ~screen~ puede ayudarte a manejar sesiones de comandos m√°s c√≥modamente.



** Pasos para Ejecutar un Comando en una TTY sin Consola F√≠sica

*** 1. Verifica qu√© TTY est√° activa
Primero, identifica en qu√© terminal TTY est√° corriendo la sesi√≥n principal. Por defecto, ~tty1~ ser√° el foco principal si tu Raspberry est√° conectada a un monitor.

Puedes verificar qu√© consola est√° activa usando:
#+begin_src bash
who
#+end_src
Esto te mostrar√° las sesiones activas y las TTY asociadas.

*** 2. Usa el Comando ~chvt~ para Cambiar de TTY
El comando ~chvt~ permite cambiar el foco de pantalla a una TTY espec√≠fica. Si, por ejemplo, quieres asegurarte de que el monitor muestre ~tty1~, puedes usar:
#+begin_src bash
sudo chvt 1
#+end_src
.
 al menos para comandos que necesiten controlar la consola al estilo de =ncurses=.*Eso s√≠, edirige un Comando a una TTY
El comando ~echo~ o la redirecci√≥n est√°ndar se pueden usar para enviar salidas a una TTY. Por ejemplo, para escribir "Hola, TTY1" en la terminal ~tty1~:
#+begin_src bash
echo "Hola, TTY1" | sudo tee /dev/tty1
#+end_src

Para ejecutar un comando y redirigir su salida, usa:
#+begin_src bash
sudo <comando> > /dev/tty1
#+end_src.
 al menos para comandos que necesiten controlar la consola al estilo de =ncurses=.
Eso s√≠, mplo, para mostrar el resultado de ~ls~:
#+begin_src bash
sudo ls /home/pi > /dev/tty1
#+end_src

*** 4. Usa ~setsid~ para Comandos Interactivos
Algunos comandos requieren una sesi√≥n activa para ejecutarse. En este caso, puedes usar ~setsid~ para lanzar una sesi√≥n independiente:
#+begin_src bash
sudo setsid <comando> > /dev/tty1 2>&1 < /dev/null
#+end_src
Esto es √∫til si el comando necesita permanecer activo o interactuar brevemente con la terminal.

.
 al menos para comandos que necesiten controlar la consola al estilo de =ncurses=.
Eso s√≠,  Pr√°ctico: Mostrar el Estado del Sistema

Si deseas que el monitor muestre continuamente informaci√≥n sobre el estado del sistema, puedes usar ~htop~ o ~top~. Por ejemplo:
#+begin_src bash
sudo setsid htop > /dev/tty1 < /dev/null
#+end_src

Si prefieres un monitoreo m√°s espec√≠fico, como mostrar la temperatura de la CPU, puedes hacer algo como:
#+begin_src bash
while true; do vcgencmd measure_temp | sudo tee /dev/tty1; sleep 1; done
#+end_src



** Automatizaci√≥n con ~rc.local~ o Servicios de Systemd

Si deseas que un comando se ejecute autom√°ticamente al arrancar la Raspberry Pi, puedes agregarlo al archivo ~/etc/rc.local~ antes de la l√≠nea ~exit 0~:
#+begin_src bash
sudo setsid <comando> > /dev/tty1 2>&1 < /dev/null &
#+end_src

Alternativamente, puedes crear un servicio de Systemd. Por ejemplo, crea un archivo de servicio:
#+begin_src bash
sudo nano /etc/systemd/system/mostrar-comando.service
#+end_src

Y agrega lo siguiente:
#+begin_src conf
[Unit]
Description=Mostrar comando en TTY1
After=multi-user.target

[Service]
ExecStart=/usr/bin/bash -c "sudo setsid <comando> > /dev/tty1 2>&1 < /dev/null"
StandardInput=tty
StandardOutput=tty
TTYPath=/dev/tty1

[Install]
WantedBy=multi-user.target
#+end_src

Luego, habilita y activa el servicio:
#+begin_src bash
sudo systemctl enable mostrar-comando.service
sudo systemctl start mostrar-comando.service
#+end_src



** Conclusi√≥n

Lanzar comandos en una TTY sin acceso f√≠sico es completamente posible y puede ser muy pr√°ctico en sistemas embebidos como una Raspberry Pi. Con herramientas como ~chvt~, redirecciones a ~/dev/ttyX~, y configuraciones autom√°ticas de servicios, puedes aprovechar al m√°ximo la pantalla conectada a tu dispositivo, incluso sin teclado f√≠sico. ¬°Pru√©balo y descubre nuevas formas de interactuar con tu Raspberry Pi!
